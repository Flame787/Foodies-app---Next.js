Installed the stable version of Next-app, not the latest version (NEVER INSTALL LATEST VERSION - INSTABILLITY!):

npx create-next-app@15.1.6 my-project --no-ts --no-tailwind --yes


React Server Components (RSC) vs. Client Components (Browser)

- Next.js is fullstack framework with frontend & backend

- by default, all React components in a Next.js project (pages, layouts or other components) are ONLY RENDERED ON THE SERVER!
  => React Server Components (RSC) - they do not execute on browser, but on server

- full code of Server components is NOT VISIBLE via Dev Tools - that is better!

What is visible in Dev tools on browser:
minimal JSON-payload with data, rendering result (HTML which was generated on the server), 
& (potencially) client-bundle, only if component uses "use client".
- But logic, functions, API calls, base access, secret variables - all stays safe on server.
- No bundled JavaScript-code in browser 
(only if client-components are being used - then full code of that component will be sent to browser and will be visible in Dev tools)

But React Server Components (RSC) are still optimal for SEO:
- Googlebot can see complete HTML content which is generated on browser, all texts, titles, meta-tags, page structure, links...
so this can be used by web-crawlers for best possible SEO

- Client Components - pre-rendered on server, but then also rendered on client (browser)
                    - they must be rendered on client, because they contain some features that are only available on browser (clientside)

Examples of features that are not available on server-side, but only on client-side:
- hooks: like useState, useEffect
- intervals, event-handlers

- if we want to build a Client Component, we have to announce it specially in Next.js:
- 'use client' directive - enables to use clientside features in a Next.js-component
- we put 'use client';  on top of any Client Component code


Github repo creation:

- start new repository (public), add some name to new repo: Foodies-app---Next.js

-> 'git init' not needed if we already created Next.app with create-next-app command (it automatically uses git & marks changes locally)

.../foodies (master)
$ git remote add origin https://github.com/Flame787/Foodies-app---Next.js.git   -> connecting our local code with newly created remote repository

.../foodies (master)
$ git remote -v            -> checking if remote repository was successfully connected, if we can make fetch or push actions to it

origin  https://github.com/Flame787/Foodies-app---Next.js.git (fetch)
origin  https://github.com/Flame787/Foodies-app---Next.js.git (push)

.../foodies (master)
$ git branch -M main
git push -u origin main

            -> *** git branch -M main  -> if your main branch is called 'master', but you want to rename it to 'main' (standard today)

Enumerating objects: 21, done.
Counting objects: 100% (21/21), done.
Delta compression using up to 12 threads
Compressing objects: 100% (21/21), done.
Writing objects: 100% (21/21), 55.38 KiB | 6.92 MiB/s, done.
Total 21 (delta 0), reused 0 (delta 0), pack-reused 0 (from 0)
To https://github.com/Flame787/Foodies-app---Next.js.git
 * [new branch]      main -> main
branch 'main' set up to track 'origin/main'.

.../foodies (main)      -> *** now main branch is called 'main', not 'master' anymore.
$ git add .             -> adding all code to the staging environment

warning: in the working copy of '.gitignore', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'app/globals.css', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'package-lock.json', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'app/layout.js', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'app/page.js', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'next.config.js', LF will be replaced by CRLF the next time Git touches it

.../foodies (main)
$ git commit -m "initial commit"       -> commiting added code, getting the 1st commit ready before publishing to GitHub

[main 7ca77c7] initial commit
 48 files changed, 562 insertions(+), 315 deletions(-)
 ... ... ...

.../foodies (main)
$ git push -u origin main         -> pushing 1st commit to GitHub (1st time, we have to write the full phrase, but later, only: git push)

Enumerating objects: 49, done.
Counting objects: 100% (49/49), done.
Delta compression using up to 12 threads
Compressing objects: 100% (41/41), done.
Writing objects: 100% (44/44), 2.34 MiB | 1.82 MiB/s, done.
Total 44 (delta 3), reused 0 (delta 0), pack-reused 0 (from 0)
remote: Resolving deltas: 100% (3/3), completed with 1 local object.
To https://github.com/Flame787/Foodies-app---Next.js.git
   5f16376..7ca77c7  main -> main
branch 'main' set up to track 'origin/main'.

-------------------------------------------------------------------

Adding an SQLite database:

npm install better-sqlite3   - package for working with SQLite database

- add code for initializing database in file initdb.js (in root of the project)
- from root of the project, run command: 
  node initdb.js
  -> this creates a new file: meals.db (but canoot be viewed with VSC editor, contains some db-data)

- in meals/page.js we don't need to use useEffect to fetch data from the base, because even frontend already run on server. 
Server components: we dont need to use fetch-requests to fetch data
Instead, we can directly reach to the data on the server.


lib - new folder in root of the project -> meals.js

*** this app is showing the App Router approach (more modern, but maybe not so stable).
But there is also Page Router approach - older, but more stable - also for building Fullstack applications with Next.js. 
- different folder structure & some other features

If using App Router approach, API-routes are defined inside of this structure:

app/       - main folder
  api/        - API-folder for organizing API-calls
    users/          - API-calls for users (among other API-calls for different themes)
      route.js            - defining a single API-route & API-calls related to that route (GET, POST, etc.)

Example of defining an API route:

// app/api/users/route.js

export async function GET() {
  return Response.json({ message: "Hello from API" })
}

export async function POST(req) {
  const data = await req.json()
  return Response.json({ received: data })
}

-------------------------------------------------

Next.js app structure for a Shop & Admin-panel app would look like this:

src/
  app/
    (shop)/            // SHOP part
      layout.js
      page.js          // HOME-page of the shop-part - MAIN ROUTE

      products/        // <domain>/products  (all products)
        page.js

        [slug]/        // <domain>/products/productXY  (product xy)
          page.js

      cart/            // <domain>/cart
        page.js

      checkout/        // <domain>/checkout
        page.js

    (admin)/           // ADMIN-PANEL part
      layout.js
      page.js           // HOME-page of the admin-part - MAIN ROUTE

      products/         // overview of all products - <admin>/products
        page.js

        new/            // a form for adding any new product  - <admin>/products/new
          page.js

        [id]/           // <admin>/products/[id]
          page.js

      orders/           // <admin>/orders
        page.js

      users/            // <admin>/users
        page.js

    api/               // defining API-calls for specific routes

      auth/                // API-calls related to authentification
        route.js

      products/            // API-calls related to products
        route.js

      products/[id]/         // API-calls related to a single product
        route.js
        
      orders/                // API-calls related to orders
        route.js

  components/           // components - can be inserted into any page.js
    ui/                   // generic components
      Button.jsx
      Input.jsx
      Modal.jsx
    shop/                 //shop-related components
      ProductCard.jsx
      ProductList.jsx
    admin/                   // admin-related components
      AdminSidebar.jsx
      AdminHeader.jsx

  lib/          // Folder lib služi za sve što je nisko‑razinski backend kod i što se koristi širom aplikacije
    db.js          // konekcija na bazu podataka
    auth.js           // autentikacija i autorizacija (provjere korisnika, dohvaćanja sessiona, zaštite ruta, 
                         integracije s NextAuth (ako ga koristiš), custom JWT logike (ako radiš ručno))
                         - koristi se i u admin panelu, i u API rutama, i u server komponentama

    validators/            // ovdje ide sve što validira podatke koji dolaze iz formi, iz API requestova, iz admin sučelja, iz checkout procesa
      productSchema.js          // definiraš pravila za proizvod: obavezan naslov, cijena u numbers, min. duljina descriptiona, mandatory category...
      userSchema.js             // pravila za validaciju usera - email, password, name mandatory, role (user, admin)
                                  -> često se koristi Zod, a onda API-calls mogu koristiti ove validatore

  services/                // poslovna “backend logika” koja se koristi u API-rutama i server-komponentama
    productService.js
    orderService.js
    userService.js

  hooks/                 // custom React hooks
    useCart.js
    useAuth.js

  styles/
    globals.css
    admin.css
    shop.css

  utils/
    formatPrice.js
    slugify.js

------------------------------------------------------------------

'use server'-directive - can be inserted inside of functions - it creates a Server Action, a function guarantied to execute on the server

async function shareMeal() {
  "use server"; 
}

- server-actions cannot be used in client-components!
 -> better solution: to store server-actions in separate files, and import them from there:
 for example: lib/actions.js - we created a special file to save our 'action'-function


 npm install slugify xss

While saving a single new meal, we would like to generate a slug for every new meal, 
and we don't get slug from the form, but we generate it here based on the title.
This is done with help of the package called 'slugify'.
We will also install package 'xss' to protect us from xss-attacks (cross-site scripting attacks) - users could post a malitious script

